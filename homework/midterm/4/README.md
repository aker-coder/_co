# Nand2Tetris Project 4: 機器語言

> ⚠️ **本文件由 AI 生成並進行內容理解與整合**

---

## 📖 專案概述

**目標**：用 Hack 機器語言編寫程式，直接操控硬體。

這是課程的轉折點：從設計硬體，進入**編程軟體**。我們使用前三章設計的硬體來執行程式。

---

## 🚀 核心概念

### 機器語言的本質
**機器語言** = 電腦硬體能直接執行的指令集，由 0 和 1 組成。

```
高階語言：  let x = 3;      (人類可讀)
    ↓
組合語言：  @3          (助記符)
            D=A
            @x
            M=D
    ↓
機器語言：  0000000000000011
            1110110000010000
            0000000000010000
            1110001100001000   (電腦可執行)
```

---

## 🛠️ Hack 機器語言規格

### 指令集

Hack 電腦支援兩種指令：

#### 1. A 指令（Address Instruction）
**格式**：`0vvvvvvvvvvvvvvv` (16 位)

```
首位：0（標識 A 指令）
後 15 位：15 位值 (0-32767)
```

**功能**：
- 將值寫入 A 暫存器
- 選擇 RAM 或 ROM 的位址

**例子**：
```
@5          → 0000000000000101    (A = 5)
@1000       → 0000001111101000    (A = 1000)
```

**常用模式**：
```
@value      (A 暫存器設為 value)
@variable   (A 暫存器設為 variable 的位址)
```

#### 2. C 指令（Compute Instruction）
**格式**：`111accccccdddjjj` (16 位)

```
首 3 位：111（標識 C 指令）
7-12 位：comp (6 位) - 計算什麼
4-6 位：dest (3 位) - 存放到哪
0-2 位：jump (3 位) - 條件跳轉
```

**Comp 運算表**：

| comp 代碼 | 運算 | 註記 |
| :--- | :--- | :--- |
| 101010 | 0 | 常數 0 |
| 111111 | 1 | 常數 1 |
| 111110 | -1 | 常數 -1 |
| 001100 | A | 從 A 暫存器讀取 |
| 110000 | D | 從 D 暫存器讀取 |
| 001101 | !A | A 的反轉 |
| 110001 | !D | D 的反轉 |
| 001111 | -A | A 的負值 |
| 110011 | -D | D 的負值 |
| 011015 | A+1 | A 加 1 |
| 110111 | D+1 | D 加 1 |
| 001110 | A-1 | A 減 1 |
| 110010 | D-1 | D 減 1 |
| 000010 | D+A | D 和 A 的和 |
| 010011 | D-A | D 減 A |
| 000111 | A-D | A 減 D |
| 000000 | D&A | D 和 A 的與 |
| 010101 | D\|A | D 和 A 的或 |

**Dest 目的地表**：

| dest | 目的地 | 說明 |
| :--- | :--- | :--- |
| 000 | null | 不儲存結果 |
| 001 | M | 存到 RAM[A] |
| 010 | D | 存到 D 暫存器 |
| 011 | MD | 同時存到 M 和 D |
| 100 | A | 存到 A 暫存器 |
| 101 | AM | 同時存到 A 和 M |
| 110 | AD | 同時存到 A 和 D |
| 111 | AMD | 同時存到 A、M 和 D |

**Jump 條件表**：

| jump | 條件 | 說明 |
| :--- | :--- | :--- |
| 000 | null | 不跳轉 |
| 001 | JGT | 若結果 > 0 則跳轉 |
| 010 | JEQ | 若結果 = 0 則跳轉 |
| 011 | JGE | 若結果 ≥ 0 則跳轉 |
| 100 | JLT | 若結果 < 0 則跳轉 |
| 101 | JNE | 若結果 ≠ 0 則跳轉 |
| 110 | JLE | 若結果 ≤ 0 則跳轉 |
| 111 | JMP | 無條件跳轉 |

**例子**：
```
D=A+1;JGT   → D ← A+1，若 (A+1)>0 則跳轉
D=D&A       → D ← D AND A，不跳轉
M=D;JEQ     → RAM[A] ← D，若 D=0 則跳轉
```

---

## 💻 編程範例

### 例 1：計算 1 + 2，結果存入 R0

```asm
@1          // A = 1
D=A         // D = 1

@2          // A = 2
D=D+A       // D = 1 + 2 = 3

@R0         // A = RAM[0] 的位址
M=D         // RAM[0] = 3
```

### 例 2：迴圈 - 計算 R0 到 R1 的值之和

```asm
@R2         // A = RAM[2]（用作累加器）
M=0         // RAM[2] = 0

(LOOP)      // 標籤：迴圈開始
@R0         // A = RAM[0]
D=M         // D = RAM[0]
@R1         // A = RAM[1]
D=D+M       // D = RAM[0] + RAM[1]
@R2         // A = RAM[2]
M=D         // RAM[2] = 和

@LOOP       // A = LOOP 標籤位址
0;JMP       // 無條件跳轉回 LOOP
```

### 例 3：條件執行 - 若 R0 > 0，則 R1 = 1，否則 R1 = 0

```asm
@R0         // A = RAM[0]
D=M         // D = RAM[0]

@R1         // A = RAM[1]
M=0         // RAM[1] = 0（預設為 0）

D;JLE       // 若 D ≤ 0 則跳轉到 END
@R1         // A = RAM[1]
M=1         // RAM[1] = 1

(END)       // 標籤：結束
@END        // A = END 標籤位址
0;JMP       // 無條件跳轉回自己（無窮迴圈，程式結束）
```

### 例 4：陣列求和 - 計算 arr[0..n-1] 的和

```asm
// 假設：
// R0 = 陣列首位址（如 256）
// R1 = 陣列長度（如 5）
// R2 = 結果（初始為 0）

@R2
M=0         // result = 0

@R1
D=M         // D = length
@i
M=D         // i = length

(LOOP)
@i
MD=M-1      // i = i-1，同時 D = i-1
@END
D;JLT       // 若 i-1 < 0 則跳轉到 END

@R0         // A = 陣列首位址
D=M         // D = 陣列首位址
@addr
M=D         // addr = 陣列首位址

@i
D=M         // D = i
@addr
M=M+D       // addr = addr + i（陣列偏移）
A=M         // A = arr[i] 的位址
D=M         // D = arr[i]

@R2
M=M+D       // result = result + arr[i]

@LOOP
0;JMP       // 迴圈回去

(END)
@END
0;JMP       // 無窮迴圈（程式結束）
```

---

## 🧠 編程技巧

### 技巧 1：使用暫存器
```
D 暫存器：用於臨時計算
A 暫存器：用於位址選擇
M = RAM[A]：間接記憶體存取
```

### 技巧 2：標籤與跳轉
```
(LABEL)     // 定義標籤
@LABEL      // 取得標籤位址
0;JMP       // 跳轉
```

### 技巧 3：尋址模式
```
@R0         // 直接暫存器 (R0-R15)
@256        // 直接位址
@arr        // 符號位址
```

### 技巧 4：複雜運算的分解
```
// 計算 RAM[100] - RAM[200]

@100        
D=M         // D = RAM[100]
@200
D=D-M       // D = D - RAM[200]
@R0
M=D         // R0 = 結果
```

### 技巧 5：迴圈計數
```
@10
D=A         // D = 10（計數器）
@counter
M=D

(LOOP)
@counter
MD=M-1      // counter = counter - 1
@END
D;JEQ       // 若 counter = 0 則結束

... (迴圈體) ...

@LOOP
0;JMP
```

---

## 📊 指令編碼

### A 指令編碼
```
@35 → 0000000000100011
       ↑首位 0
       └─值 35 = 0x0023
```

### C 指令編碼範例

| 助記符 | 二進位編碼 | 說明 |
| :--- | :--- | :--- |
| D=A | 1110110000010000 | comp=110000(A), dest=010(D) |
| D=D+A | 1110000010010000 | comp=000010(D+A), dest=010(D) |
| M=D | 1110110000001000 | comp=110000(D), dest=001(M) |
| D;JMP | 1110110000010111 | comp=110000(D), jump=111(JMP) |

---

## 🎓 關鍵理解

### 1. 抽象級別
```
高階語言     (Java, C, Python)
    ↓
組合語言     (Hack Assembly)
    ↓
機器語言     (0 和 1)
    ↓
硬體電路     (邏輯門)
```

### 2. 馮紐曼架構
```
CPU
├─ 控制單元 (Control)
├─ ALU      (Arithmetic Logic Unit)
└─ 暫存器   (Registers)
    ↓
記憶體 (Memory)
    ↓
I/O 設備 (Keyboard, Screen)
```

### 3. 程式執行模型
```
ROM[PC] → 解碼 → 執行 → PC++ (或跳轉)
```

---

## 📁 檔案清單

```
Project 4: Machine Language
├── Mult.asm        (乘法程式)
├── Fill.asm        (螢幕填充程式)
└── 其他測試程式
```

---

## ✅ 學習成果

完成此章節後，你將理解：
- ✅ Hack 指令集的結構（A 和 C 指令）
- ✅ 暫存器與記憶體的使用
- ✅ 跳轉與迴圈的實現
- ✅ 符號和標籤的作用
- ✅ 從高階語言到機器語言的轉換

---

## 💡 從組合語言到機器語言

編寫程式的工作流程：
1. **設計算法**（高階思維）
2. **轉換為組合語言**（中級表示）
3. **組譯器轉換**（自動生成機器碼）
4. **加載到 ROM**
5. **執行**

第 6 章的**組譯器**會自動完成步驟 3，你在此章主要手寫組合語言來理解底層原理。

---

> 🎯 **掌握機器語言，你就掌握了電腦的靈魂。雖然現代我們用高階語言編程，但理解底層機制對成為真正的工程師至關重要。**
