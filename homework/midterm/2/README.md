# Nand2Tetris Project 2: 布爾算術與 ALU

> ✨ **本文件為原創內容**

---

## 📖 專案概述

**目標**：使用第 1 章的邏輯門，構建二進位加法器與 ALU (Arithmetic Logic Unit，算術邏輯單元)。

這是從**邏輯層**進入**算術層**的關鍵一步。我們將看到如何用簡單的邏輯運算組合成強大的計算能力。

---

## 🚀 核心概念

### 二進位加法原理

#### 半加器 (Half Adder)
執行單一位元的加法。

| A | B | Sum | Carry |
| :--- | :--- | :--- | :--- |
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

**實作邏輯**：
```
Sum   = A XOR B
Carry = A AND B
```

#### 全加器 (Full Adder)
處理進位，執行 A + B + Cin 的加法。

| A | B | Cin | Sum | Cout |
| :--- | :--- | :--- | :--- | :--- |
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |

**實作邏輯**：
```
Sum  = (A XOR B) XOR Cin
Cout = (A AND B) OR ((A XOR B) AND Cin)
```

#### 多位元加法器 (16-bit Adder)
級聯 16 個全加器，將每個加器的進位輸出連接到下一個加器的進位輸入。

```
A[15..0] + B[15..0] = Out[15..0]
Cin → FA(0) → Cin → FA(1) → ... → FA(15) → Cout
```

---

## 🛠️ 實作內容

### 第 1 級：基礎加法器

| 元件 | 功能 | 輸入 | 輸出 |
| :--- | :--- | :--- | :--- |
| **HalfAdder** | 無進位加法 | a, b | sum, carry |
| **FullAdder** | 有進位加法 | a, b, c | sum, carry |
| **Add16** | 16 位加法 | a[16], b[16] | out[16] |

### 第 2 級：算術增強

| 元件 | 功能 | 實作 |
| :--- | :--- | :--- |
| **Inc16** | 增加 1 | `Add16(a=in, b=00...001)` |
| **ALU** | 完整算術邏輯單元 | 見下節 |

### 第 3 級：ALU - 核心處理器

**32 種運算**（透過控制位選擇）：

| zx | nx | zy | ny | f | no | 運算 |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1 | 0 | 1 | 0 | 1 | 0 | **0** |
| 1 | 1 | 1 | 1 | 1 | 1 | **1** |
| 1 | 1 | 1 | 0 | 1 | 0 | **-1** |
| 0 | 0 | 1 | 1 | 0 | 0 | **x** |
| 1 | 1 | 0 | 0 | 0 | 0 | **y** |
| 0 | 0 | 1 | 1 | 0 | 1 | **!x** |
| 1 | 1 | 0 | 0 | 0 | 1 | **!y** |
| 0 | 0 | 1 | 1 | 1 | 1 | **-x** |
| 1 | 1 | 0 | 0 | 1 | 1 | **-y** |
| 0 | 1 | 1 | 1 | 1 | 1 | **x+1** |
| 1 | 1 | 0 | 1 | 1 | 1 | **y+1** |
| 0 | 0 | 1 | 0 | 1 | 1 | **x-1** |
| 1 | 1 | 0 | 0 | 1 | 0 | **y-1** |
| 0 | 0 | 0 | 0 | 1 | 0 | **x+y** |
| 0 | 1 | 0 | 0 | 1 | 1 | **x-y** |
| 0 | 0 | 0 | 1 | 1 | 1 | **y-x** |
| 0 | 0 | 0 | 0 | 0 | 0 | **x&y** |
| 0 | 1 | 0 | 1 | 0 | 1 | **x\|y** |

---

## 🧠 ALU 詳細設計

### 內部結構

```
    x[16]     y[16]
       ↓          ↓
    [Mux16]   [Mux16]      ← 決定是否將輸入改為 0
       ↓          ↓
    [Not16]   [Not16]      ← 決定是否反轉
       ↓          ↓
       x'        y'
       ↓          ↓
    ┌─────────────┴─────────────┐
    │  [And16] 或 [Add16]?      │ ← f 控制位選擇運算
    ↓
  result[16]
    │
  [Not16]        ← 決定是否反轉結果
    │
  [output]
    └─→ zr (zero flag)
    └─→ ng (negative flag)
```

### 控制信號解釋

| 位名 | 功能 |
| :--- | :--- |
| **zx** | 若 zx=1，則將 x 設為 0 |
| **nx** | 若 nx=1，則反轉 x (NOT x) |
| **zy** | 若 zy=1，則將 y 設為 0 |
| **ny** | 若 ny=1，則反轉 y (NOT y) |
| **f** | 若 f=0，執行 AND；若 f=1，執行 ADD |
| **no** | 若 no=1，則反轉輸出 (NOT output) |

### 輸出標誌

| 標誌 | 含義 |
| :--- | :--- |
| **zr** | Zero flag - 若結果為 0 則置 1 |
| **ng** | Negative flag - 若結果為負（最高位為 1）則置 1 |

**應用**：用於條件分支（`if` 邏輯）。

---

## 💡 實作亮點

### 1. 進位鏈 (Carry Ripple)
加法器級聯時，進位逐位傳播：
- **優點**：設計簡單，邏輯清晰
- **缺點**：延遲隨位寬增加而累積（O(n)）
- **改進**：進位預測加法器 (CLA) 可達 O(log n)

### 2. 多工化設計
ALU 用多工器根據控制位選擇不同運算，避免了龐大的邏輯門陣列。

```
操作序列：
1. 前置處理 (zx, nx, zy, ny) → 調整輸入
2. 運算選擇 (f) → AND 或 ADD
3. 後置處理 (no) → 調整輸出
4. 標誌提取 (zr, ng) → 狀態反饋
```

### 3. 完整性與最小性
- **完整性**：32 種運算涵蓋了絕大多數計算需求
- **最小性**：只需 6 個控制位，而非 32 個獨立控制線路

---

## 🔧 HDL 設計模式

### 加法器組合
```hdl
CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];
    
    PARTS:
    HalfAdder(a=a[0], b=b[0], sum=out[0], carry=c0);
    FullAdder(a=a[1], b=b[1], c=c0, sum=out[1], carry=c1);
    FullAdder(a=a[2], b=b[2], c=c1, sum=out[2], carry=c2);
    // ... 依此類推到 15
    FullAdder(a=a[15], b=b[15], c=c14, sum=out[15], carry=c15);
}
```

### ALU 的多工邏輯
```hdl
CHIP ALU {
    IN x[16], y[16],
       zx, nx, zy, ny, f, no;
    OUT out[16],
        zr, ng;
    
    PARTS:
    // 前置處理
    Mux16(a=x, b=false, sel=zx, out=x0);
    Not16(in=x0, out=nx0);
    Mux16(a=x0, b=nx0, sel=nx, out=x1);
    // ... y 的同樣處理
    
    // 運算選擇
    And16(a=x1, b=y1, out=and_out);
    Add16(a=x1, b=y1, out=add_out);
    Mux16(a=and_out, b=add_out, sel=f, out=out0);
    
    // 後置處理
    Not16(in=out0, out=nout0);
    Mux16(a=out0, b=nout0, sel=no, out=out, 
          out[15]=isNeg, out[0..15]=out_slice);
    
    // 標誌提取
    Or8Way(in=out_slice[0..7], out=or1);
    Or8Way(in=out_slice[8..15], out=or2);
    Or(a=or1, b=or2, out=or_all);
    Not(in=or_all, out=zr);
    And(a=isNeg, b=true, out=ng);
}
```

---

## 📊 複雜度分析

| 元件 | 邏輯層 | AND/OR 數量 |
| :--- | :--- | :--- |
| HalfAdder | 2 | 3 |
| FullAdder | 3 | 8 |
| Add16 | 16 | ~128 |
| ALU | 20+ | ~400 |

**觀察**：ALU 的複雜度已相當高，但對於現代處理器而言仍是相對基礎的元件。

---

## 🎓 關鍵理解

### 1. 算術的邏輯基礎
二進位加法最終可分解為：
- **XOR** (加法位)
- **AND** (進位位)

所有更複雜的運算都建立在這兩個基本操作之上。

### 2. 控制的力量
僅用 6 個控制位就能實現 32 種不同的運算，展現了**編碼 (Encoding)** 的強大威力。

### 3. 功能與性能的折衝
- 多工化設計 → 簡化邏輯但可能增加延遲
- 專用電路 → 快速但佔用更多面積

---

## 📁 檔案清單

```
Project 2: Boolean Arithmetic
├── HalfAdder.hdl / .tst / .cmp
├── FullAdder.hdl / .tst / .cmp
├── Add16.hdl / .tst / .cmp
├── Inc16.hdl / .tst / .cmp
└── ALU.hdl / .tst / .cmp
```

---

## ✅ 學習成果

完成此章節後，你將理解：
- ✅ 二進位加法的原理與實作
- ✅ 進位鏈的概念與延遲特性
- ✅ ALU 作為處理器核心的角色
- ✅ 控制信號如何實現多種運算
- ✅ 標誌位在條件判斷中的用途

---

> 🎯 **ALU 是處理器的心臟。掌握它，你就掌握了運算的本質。**
